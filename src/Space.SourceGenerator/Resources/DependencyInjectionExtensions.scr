// <auto-generated>
//     Generated by the Space source generator.
// </auto-generated>

using System;
using System.Threading.Tasks;
using System.Reflection;
using System.Linq;
using Space.Abstraction;
using Space.Abstraction.Context;
using Space.Abstraction.Registry;
using Space.Abstraction.Modules;
using Space.Abstraction.Registry.Dispatchers;
using Microsoft.Extensions.DependencyInjection;
using Space.Abstraction.Helpers; // shared helpers

namespace Space.DependencyInjection
{
    public static class SourceGeneratorDependencyInjectionExtensions
    {
        public static IServiceCollection AddSpaceSourceGenerated(this IServiceCollection services)
            => AddSpaceInternal(services, new SpaceOptions());

        public static IServiceCollection AddSpaceSourceGenerated(this IServiceCollection services, Action<SpaceOptions> configure)
        {
            var opt = new SpaceOptions();
            configure?.Invoke(opt);
            return AddSpaceInternal(services, opt);
        }

        private static IServiceCollection AddSpaceInternal(IServiceCollection services, SpaceOptions options)
        {
            // Core registrations (root aggregator)
            services.AddSingleton<ISpace, global::Space.DependencyInjection.Space>();
            services.AddSingleton<ModuleFactory>();

            if (options.NotificationDispatchType == NotificationDispatchType.Parallel)
                services.AddSingleton<INotificationDispatcher, ParallelNotificationDispatcher>();
            else
                services.AddSingleton<INotificationDispatcher, SequentialNotificationDispatcher>();

            // Discover assembly-scoped registration helper types generated in referenced projects
            var registrationTypes = AppDomain.CurrentDomain.GetAssemblies()
                .SelectMany(a => SafeGetTypes(a))
                .Where(t => t.IsClass && t.IsAbstract && t.IsSealed && t.Name.StartsWith("SpaceAssemblyRegistration_", StringComparison.Ordinal))
                .ToArray();

            // Register external assembly handler service types BEFORE building provider
            foreach (var rt in registrationTypes)
            {
                var ms = rt.GetMethod("RegisterAssemblyServices", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                if (ms != null)
                {
                    try { ms.Invoke(null, new object[] { services, options.ServiceLifetime }); } catch { /* ignore */ }
                }
            }

            // Also register handlers belonging to root assembly (current project)
            var handlerTypes = new Type[] {
                {{ for handler in AllHandlersName }}
                typeof({{ handler }}),
                {{ end }}
            };
            foreach (var t in handlerTypes)
                services.Add(new ServiceDescriptor(t, t, options.ServiceLifetime));

            services.AddSingleton<SpaceRegistry>(sp =>
            {
                var registry = new SpaceRegistry(sp);
                registry.HandlerLifetime = options.ServiceLifetime;
                bool isSingleton = options.ServiceLifetime == ServiceLifetime.Singleton;

                {{ if NeedsReg }}
                void Reg<THandler, TReq, TRes>(string name, Func<THandler, HandlerContext<TReq>, ValueTask<TRes>> body,
                                                System.Collections.Generic.IEnumerable<(PipelineConfig config, PipelineInvoker<TReq, TRes> invoker)> pipes = null)
                {
                    THandler singleton = isSingleton ? sp.GetRequiredService<THandler>() : default!;
                    registry.RegisterHandler<TReq, TRes>(ctx =>
                    {
                        var inst = isSingleton ? singleton : ctx.ServiceProvider.GetRequiredService<THandler>();
                        return body(inst, ctx);
                    }, name, pipes, null);
                }
                {{ end }}

                {{ if NeedsRegLight }}
                void RegLight<THandler, TReq, TRes>(string name, Func<THandler, HandlerContext<TReq>, ValueTask<TRes>> body)
                {
                    THandler singleton = isSingleton ? sp.GetRequiredService<THandler>() : default!;
                    HandlerInvoker<TReq, TRes> normal = ctx =>
                    {
                        var inst = isSingleton ? singleton : ctx.ServiceProvider.GetRequiredService<THandler>();
                        return body(inst, ctx);
                    };

                    LightHandlerInvoker<TReq, TRes> light = SpaceGeneratorRuntimeHelpers.CreateLightInvoker<TReq, THandler, TRes>(singleton, isSingleton, body);

                    registry.RegisterHandler<TReq, TRes>(normal, name, null, light);
                }
                {{ end }}

                {{ if NeedsRegPipe }}
                void RegPipe<TReq, TRes, TPipe>(string handlerName, PipelineConfig cfg, Func<TPipe, PipelineContext<TReq>, PipelineDelegate<TReq, TRes>, ValueTask<TRes>> invoker)
                {
                    if (isSingleton)
                    {
                        // Cache pipeline instance once for singleton lifetime to avoid per-call DI resolution
                        var pipeInstance = sp.GetRequiredService<TPipe>();
                        registry.RegisterPipeline<TReq, TRes>(handlerName, cfg, (ctx, next) => invoker(pipeInstance, ctx, next));
                    }
                    else
                    {
                        registry.RegisterPipeline<TReq, TRes>(handlerName, cfg, (ctx, next) =>
                        {
                            var pipe = ctx.ServiceProvider.GetRequiredService<TPipe>();
                            return invoker(pipe, ctx, next);
                        });
                    }
                }
                {{ end }}

                {{ if NeedsRegModule }}
                void RegModule<TReq, TRes>(string handlerName, string moduleName, string profileName)
                {
                    registry.RegisterModule<TReq, TRes>(moduleName, handlerName, profileName);
                }
                {{ end }}

                {{ if NeedsRegNotification }}
                void RegNotification<TReq, THandler>(Func<THandler, NotificationContext<TReq>, ValueTask> call)
                {
                    if (isSingleton)
                    {
                        var inst = sp.GetRequiredService<THandler>();
                        registry.RegisterNotification<TReq>(ctx => call(inst, ctx));
                    }
                    else
                    {
                        registry.RegisterNotification<TReq>(ctx =>
                        {
                            var h = ctx.ServiceProvider.GetRequiredService<THandler>();
                            return call(h, ctx);
                        });
                    }
                }
                {{ end }}

                // Root assembly notifications
                {{ for n in Notifications }}
                RegNotification<{{ n.RequestParameterTypeName }}, {{ n.ClassFullName }}>((inst, ctx) => inst.{{ n.MethodName }}(ctx));
                {{ end }}

                // Root assembly handlers / pipelines / modules
                {{ for h in OrderedHandlers }}
                {{ if (h.PipelineCompileModels.size == 0 && h.ModuleCompileModels.size == 0) }}
                RegLight<{{ h.ClassFullName }}, {{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}>("{{ h.HandlerName }}",
                    (inst, ctx) => {{ if h.IsValueTask }} inst.{{ h.MethodName }}(ctx) {{ else }} SpaceGeneratorRuntimeHelpers.VT(inst.{{ h.MethodName }}(ctx)) {{ end }});
                {{ else }}
                Reg<{{ h.ClassFullName }}, {{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}>("{{ h.HandlerName }}",
                    (inst, ctx) => {{ if h.IsValueTask }} inst.{{ h.MethodName }}(ctx) {{ else }} SpaceGeneratorRuntimeHelpers.VT(inst.{{ h.MethodName }}(ctx)) {{ end }});

                    {{ for p in h.PipelineCompileModels }}
                    RegPipe<{{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}, {{ p.ClassFullName }}>("{{ h.HandlerName }}",
                        new PipelineConfig(){ Order = {{ p.Order }} },
                        (pipe, ctx, next) => {{ if p.IsValueTask }} pipe.{{ p.MethodName }}(ctx, next) {{ else }} SpaceGeneratorRuntimeHelpers.VT(pipe.{{ p.MethodName }}(ctx, next)) {{ end }});
                    {{ end }}

                    {{ for m in h.ModuleCompileModels }}
                    RegModule<{{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}>("{{ h.HandlerName }}", "{{ m.ModuleName }}", "{{m.Profile}}");
                    {{ end }}
                {{ end }}
                {{ end }}

                // External assemblies handler registrations
                foreach (var rt in registrationTypes)
                {
                    var mh = rt.GetMethod("RegisterAssemblyHandlers", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
                    if (mh != null)
                    {
                        try { mh.Invoke(null, new object[] { sp, registry, isSingleton }); } catch { /* ignore */ }
                    }
                }

                registry.CompleteRegistration();
                return registry;
            });

            return services;
        }

        private static System.Collections.Generic.IEnumerable<Type> SafeGetTypes(Assembly a)
        {
            try { return a.GetTypes(); }
            catch (ReflectionTypeLoadException ex) { return ex.Types.Where(t => t != null)!; }
            catch { return Array.Empty<Type>(); }
        }
    }
}