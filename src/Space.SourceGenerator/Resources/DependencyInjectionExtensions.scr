// <auto-generated>
//     Generated by the Space source generator.
// </auto-generated>

using System;
using System.Threading.Tasks;
using Space.Abstraction;
using Space.Abstraction.Context;
using Space.Abstraction.Registry;
using Space.Abstraction.Modules;
using Space.Abstraction.Registry.Dispatchers;
using Microsoft.Extensions.DependencyInjection;

namespace Space.DependencyInjection
{
    public static class SourceGeneratorDependencyInjectionExtensions
    {
        // Light invoker state holder (per TReq per thread)
        internal static class LightInvokerState<TReq, THandler, TRes>
        {
            [ThreadStatic] private static HandlerContext<TReq> _ctx;
            public static ValueTask<TRes> Invoke(in LightHandlerContext<TReq> lctx, THandler singleton, bool isSingleton,
                                                 Func<THandler, HandlerContext<TReq>, ValueTask<TRes>> body)
            {
                var ctx = _ctx;
                if (ctx == null)
                {
                    ctx = new HandlerContext<TReq>();
                    _ctx = ctx;
                }
                ctx.Initialize(lctx.Request, lctx.ServiceProvider, lctx.Space, lctx.CancellationToken);
                var inst = isSingleton ? singleton : ctx.ServiceProvider.GetRequiredService<THandler>();
                return body(inst, ctx);
            }
        }

        public static IServiceCollection AddSpaceSourceGenerated(this IServiceCollection services)
            => AddSpaceInternal(services, new SpaceOptions());

        public static IServiceCollection AddSpaceSourceGenerated(this IServiceCollection services, Action<SpaceOptions> configure)
        {
            var opt = new SpaceOptions();
            configure?.Invoke(opt);
            return AddSpaceInternal(services, opt);
        }

        private static IServiceCollection AddSpaceInternal(IServiceCollection services, SpaceOptions options)
        {
            // Core registrations
            services.AddSingleton<ISpace, global::Space.DependencyInjection.Space>();
            services.AddSingleton<ModuleFactory>();

            if (options.NotificationDispatchType == NotificationDispatchType.Parallel)
                services.AddSingleton<INotificationDispatcher, ParallelNotificationDispatcher>();
            else
                services.AddSingleton<INotificationDispatcher, SequentialNotificationDispatcher>();

            // Batch register handler types (trailing comma style to avoid loop.last logic)
            var handlerTypes = new Type[] {
                {{ for handler in AllHandlersName }}
                typeof({{ handler }}),
                {{ end }}
            };
            foreach (var t in handlerTypes)
                services.Add(new ServiceDescriptor(t, t, options.ServiceLifetime));

            services.AddSingleton<SpaceRegistry>(sp =>
            {
                var registry = new SpaceRegistry(sp);
                registry.HandlerLifetime = options.ServiceLifetime;
                bool isSingleton = options.ServiceLifetime == ServiceLifetime.Singleton;

                static ValueTask<T> VT<T>(Task<T> task) => task.IsCompletedSuccessfully ? new ValueTask<T>(task.Result) : new ValueTask<T>(task);

                void Reg<THandler, TReq, TRes>(string name, Func<THandler, HandlerContext<TReq>, ValueTask<TRes>> body,
                                                System.Collections.Generic.IEnumerable<(PipelineConfig config, PipelineInvoker<TReq, TRes> invoker)> pipes = null)
                {
                    THandler singleton = isSingleton ? sp.GetRequiredService<THandler>() : default!;
                    registry.RegisterHandler<TReq, TRes>(ctx =>
                    {
                        var inst = isSingleton ? singleton : ctx.ServiceProvider.GetRequiredService<THandler>();
                        return body(inst, ctx);
                    }, name, pipes, null);
                }

                void RegLight<THandler, TReq, TRes>(string name, Func<THandler, HandlerContext<TReq>, ValueTask<TRes>> body)
                {
                    THandler singleton = isSingleton ? sp.GetRequiredService<THandler>() : default!;
                    HandlerInvoker<TReq, TRes> normal = ctx =>
                    {
                        var inst = isSingleton ? singleton : ctx.ServiceProvider.GetRequiredService<THandler>();
                        return body(inst, ctx);
                    };

                    LightHandlerInvoker<TReq, TRes> light = (in LightHandlerContext<TReq> lctx) =>
                        LightInvokerState<TReq, THandler, TRes>.Invoke(in lctx, singleton, isSingleton, body);

                    registry.RegisterHandler<TReq, TRes>(normal, name, null, light);
                }

                void RegPipe<TReq, TRes, TPipe>(string handlerName, PipelineConfig cfg, Func<TPipe, PipelineContext<TReq>, PipelineDelegate<TReq, TRes>, ValueTask<TRes>> invoker)
                {
                    registry.RegisterPipeline<TReq, TRes>(handlerName, cfg, (ctx, next) =>
                    {
                        var pipe = ctx.ServiceProvider.GetRequiredService<TPipe>();
                        return invoker(pipe, ctx, next);
                    });
                }

                void RegModule<TReq, TRes>(string handlerName, string moduleName, string profileName)
                {
                    registry.RegisterModule<TReq, TRes>(moduleName, handlerName, profileName);
                }

                // Notifications
                {{ for n in Notifications }}
                registry.RegisterNotification<{{ n.RequestParameterTypeName }}>((ctx) =>
                {
                    var h = ctx.ServiceProvider.GetRequiredService<{{ n.ClassFullName }}>();
                    return h.{{ n.MethodName }}(ctx);
                }, "{{ n.HandlerName }}");
                {{ end }}

                // Handlers / Pipelines / Modules
                {{ for h in OrderedHandlers }}
                {{ if (h.PipelineCompileModels.size == 0 && h.ModuleCompileModels.size == 0) }}
                // Light path (no pipelines/modules)
                RegLight<{{ h.ClassFullName }}, {{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}>("{{ h.HandlerName }}",
                    (inst, ctx) => {{ if h.IsValueTask }} inst.{{ h.MethodName }}(ctx) {{ else }} VT(inst.{{ h.MethodName }}(ctx)) {{ end }});
                {{ else }}
                Reg<{{ h.ClassFullName }}, {{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}>("{{ h.HandlerName }}",
                    (inst, ctx) => {{ if h.IsValueTask }} inst.{{ h.MethodName }}(ctx) {{ else }} VT(inst.{{ h.MethodName }}(ctx)) {{ end }});

                    {{ for p in h.PipelineCompileModels }}
                    RegPipe<{{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}, {{ p.ClassFullName }}>("{{ h.HandlerName }}",
                        new PipelineConfig(){ {{ for prop in p.Properties }} {{ prop.Key }} = {{ prop.Value }},{{ end }} },
                        (pipe, ctx, next) => {{ if p.IsValueTask }} pipe.{{ p.MethodName }}(ctx, next) {{ else }} VT(pipe.{{ p.MethodName }}(ctx, next)) {{ end }});
                    {{ end }}

                    {{ for m in h.ModuleCompileModels }}
                    RegModule<{{ h.RequestParameterTypeName }}, {{ h.ReturnTypeName }}>("{{ h.HandlerName }}", "{{ m.ModuleName }}", "{{m.Profile}}");
                    {{ end }}
                {{ end }}
                {{ end }}

                registry.CompleteRegistration();
                return registry;
            });

            return services;
        }
    }
}